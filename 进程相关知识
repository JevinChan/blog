	“会话/进程组/线程组”几个概念呈现层级关系, Linux 系统中可以有多个会话(session),
每个会话可以包含多个进程组(process group),每个进程组可以包含多个进程,每个进程构
成一个线程组——一个线程组由一个进程内的一个或多个线程组成,这些对象都有各自的 PID。
会话是用户登陆系统到退出前的全部活动,不同帐户的登录属于不同会话,而同一帐户的多次登录也构成不同的会话。而进程组主要出于作业控制的目的,有些Shell没有作业控制能力,就将整个会话的所有进程构成一个进程组。
	每当用户登录到 Unix 主机时,系统将打开一个终端运行 login 程序等待输入用户名和密码,
通过密码验证后则创建一个 shell 程序从该终端读取用户命令和输出显示信息,由该 shell 创建
的所有进程都使用这个终端,即同一会话所有进程使用相同终端。从登陆到结束前创建的所有
进程都属于这次会话(session),第一个被创建的进程(通常是 shell)称为会话的领头进程
(session leader),而系统打开的那个终端就是这些进程的控制终端。进程打开/dev/tty 可以
获得当前进程的控制终端文件描述符 fd (没有控制终端的进程则会失败),用库函数 tcgetsid(fd)
可以获得会话 ID(SID)。除了用户登录而产生的会话外,守护进程利用 setsid()系统调用
(linux-3.13/kernel/sys.c)及其它相关操作建立自己的会话和进程组,这类会话与用户登录会
话相互独立避免相互影响,而且守护进程的会话是没有控制终端的。
	在 shell 上的一条命令所产生的所有进程形成一个进程组,
每个进程组内第一个进程往往成为领头进程(process group leader),
并以领头进程的 PID 为组内进程的 PGID。进程组的生命周期持续到组中最后一个进程终止,
或加入其他进程组为止。可以利用 getpgrp()系统调用来获取进程组 ID。但是如果 shell 没有作业控制(job control)能力则不管理进程组,例如 bash 中创建的进程都属于同一个会话、同一
个进程组。一个带有控制终端的会话有一个前台进程组( foreground process group),还可以有一
个或多个后台进程组(background process group)。
	进程刚创建时只有一个主线程,此时 task_struct->group_leader 指向自己,其后创建的线
程 task_struct->group_leader 指向线程组长(主线程)。主线程 task_struct->thread_group 作为链表头,其他子线程通过 task_struct->thread_group 构成链表。
	进程组提供了一个机制,让信号可以发送给组内的所有进程,这使得作业控制和其他 shell
活动变得简单。其中前台进程连接到控制终端,若在控制终端键入中断键(Ctrl-C 或 Delete)
或退出键(Ctrl-\),就会造成将中断信号 SIGINT 或退出信号 SIGQUIT 送至前台进程组的所有
进程,无需一个一个地处理。挂起键(Ctrl+Z)对应的 SIGTSTP 也发送给前台进程组的所有进
程。而检测到终端的 modem 或网络断线时,SIGHUP 将发给会话领头进程,(!!!当会话领头进程
终止后内核还会将此信号送往前台进程组,进程组的默认动作是终止进程)。如果禁止后台进程
组操作终端后,后台进程进行终端读写操作则引发 SIGTTOU 或 SIGTTIN 信号。

ps命令：
	常用参数：
	-o 用户自定义格式 (ps -eo pid,stat,pri,uid –sort uid)
	-A 显示所有进程（等价于-e）(utility)
	-a 显示一个终端的所有进程，除了会话引线
	-x 显示没有控制终端的进程，同时显示各个命令的具体路径
	-p pid 进程使用cpu的时间
	-u uid or username 选择有效的用户id或者是用户名
	-g gid or groupname 显示组的所有进程
	-j 作业格式
	s 以信号格式显示
	-m 显示所有的线程
	-t <终端机编号> 　指定终端机编号，并列出属于该终端机的程序的状况

killall命令：
	-e 要求匹配进程名称
	-I 忽略小写
	-g 杀死进程组而不是进程
	-i 交互模式，杀死进程前先询问用户
	-l 列出所有的已知信号名称
	-s 发送指定的信号
	-v 报告信号是否成功发送
	-w 等待进程死亡
	-u 杀死指定用户进程，命令名可选
	kill name 杀死同名进程
